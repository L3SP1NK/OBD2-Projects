/***************************************************************************
                          tcan_com2.c  -  description
                             -------------------
    begin             : 06.05.2017
    last modify       : 20.04.2023    
    copyright         : (C) 2017 - 2023 by MHS-Elektronik GmbH & Co. KG, Germany
    author            : Klaus Demlehner, klaus@mhs-elektronik.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software, you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License           *
 *   version 2.1 as published by the Free Software Foundation.             *
 *                                                                         *
 ***************************************************************************/

/**
    Library to talk to Tiny-CAN devices. You find the latest versions at
       http://www.tiny-can.com/
**/
#include "global.h"
#include <string.h>  // memcpy
#include <stdio.h>
#include <stdlib.h>
#include "util.h"
#include "sm_drv.h"
#include "can_fifo.h"
#include "can_puffer.h"
#include "can_core.h"
#include "log.h"
#include "errors.h"
#include "tar_drv.h"
#include "tar_drv2.h"
#include "ecu_flash.h"
#ifdef ENABLE_RS485_SUPPORT // <*> neu
  #include "rs485.h"
#endif
#include "tcan_com2.h"

#define STATUS_READ_TIMEOUT     3000        // Status mindestens alle 3 Sekunden lesen
#define TX_CAN_PKT_MAX_SIZE     14      
#define TX_CAN_FD_PKT_MAX_SIZE  70 


/**************************************************************************/
/*                             Kommandos                                  */
/**************************************************************************/
#define CMD2_COM                0x24 | CMD_TYPE_EXT2 


#define DATA_STREM_NO_CAN_FLAG  0x80
#define DATA_STREM_EFF_FLAG     0x40
#define DATA_STREM_RTR_FLAG     0x20
#define DATA_STREM_TX_FLAG      0x10
#define DATA_STREM_FD_FLAG      0x08
#define DATA_STREM_CAN_CHANNEL  0x07

#define DATA_STREM_BRS_FLAG     0x80


/*

#######################################################################################################################
#                                                     K O M M A N D O                                                 #
#######################################################################################################################

   +===============================================================+
   |  No CAN Frame = 1  |              Kommando                    |
   +--------------------+------------------------------------------+
   |  No CAN Frame = 1  |              Kommando ...                |
   +--------------------+------------------------------------------+
   |  No CAN Frame = 1  |              Kommando n                  |
   +===============================================================+
   |  No CAN Frame = 0  |          TxD CAN Nachrichten             |
   +--------------------+------------------------------------------+
   |  No CAN Frame = 0  |          TxD CAN Nachrichten ...         |
   +--------------------+------------------------------------------+
   |  No CAN Frame = 0  |          TxD CAN Nachrichten n           |
   +===============================================================+


Liste aller Kommandos:  
  0x01 = Time-Stamp
  0x02 = CAN Status
  0x03 = TxCAN Status
  0x06 = Keys (wird nicht angefordert)
  0x07 = Read Analog Inputs
  0x08 = RS485 I/O  (Beschreibung in RS485.c)  // <*> neu, Optional
  0x1x = Set Digital Outputs
  0x2x = Read Digital Inputs  
  0x3x = Read Incremental Inputs
  0x4x = Set Analog Outputs
  0x5x = Data (ECU Flash) 
  0x6x = Puffer Message x = Puffer Index 0 - 7
  0x7x = Filter Message x = Filter Index 0 - 7, 0x7F = Alle Filter abfragen


Set Digital Outputs
=================== 

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |           Set Digital Outputs           |   Dig.-Out  |   Dig.-Out  |  Dig.-Out   |  Dig.-Out   |
      |      1      |      0             0             1      |   48 - 63   |   32 - 47   |  16 - 31    |   0 - 15    |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |                                                                                                               |
      +-----------                                    Digital Outputs x                                    -----------+
   3  |                                                                                                               |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   .. |                                                                                                               |
      +-----------                                    Digital Outputs x                                    -----------+
   .. |                                                                                                               |               
      +=============+=============+=============+=============+=============+=============+=============+=============+


Read Digital Inputs
=================== 

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |           Read Digital Inputs           |   Dig.-In   |   Dig.-In   |  Dig.-In    |  Dig.-In    |
      |      1      |      0      |      1      |      0      |   48 - 63   |   32 - 47   |  16 - 31    |   0 - 15    |
      +=============+=============+=============+=============+=============+=============+=============+=============+


Read Analog Inputs
==================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                                       Indx                                                      |
      |      1      |                               0x07 = Read Analog Inputs                                         |      
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |    AIN 7    |    AIN 6    |    AIN 5    |    AIN 4    |    AIN 3    |    AIN 2    |    AIN 1    |    AIN 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+


Read Incremental Inputs
=======================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |         Read Incremental Inputs         |   Encoder   |   Encoder   |   Encoder   |   Encoder   |
      |      1      |      0      |      1      |      1      |      3      |      2      |      1      |      0      |
      +=============+=============+=============+=============+=============+=============+=============+=============+


Set Analog Outputs
================== 

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |            Set Analog Outputs           |  Analog Out |  Analog Out |  Analog Out |  Analog Out |
      |      1      |      1             0             0      |      3      |      2      |      1      |      0      |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |                                                                                                               |
      +-----------                                     Analog Output x                                     -----------+
   3  |                                                                                                               |
      +-------------+-------------+-------------+------------+-------------+-------------+-------------+-------------+
   .. |                                                                                                               |
      +-----------                                     Analog Output x                                     -----------+
   .. |                                                                                                               |               
      +=============+=============+=============+=============+=============+=============+=============+=============+


Data (ECU Flash)
================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                   Data                  |    Data     |                Kommando                 |
      |      1      |      1      |      0      |      1      |      x      |      x      |     x       |      x      |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |                                                                                                               |
      +-----------                                          Data                                           -----------+      
   x  |                                                                                                               |
      +=============+=============+=============+=============+=============+=============+=============+=============+


Kommandos: Time-Stamp, CAN Status, TxCAN Status
===============================================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                                       Command                                                   |
      |      1      |                                                                                                 |
      +=============+=============+=============+=============+=============+=============+=============+=============+


Kommando: Filter abfragen
=========================
  
 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                                 Command / Index                                                 |
      |      1      |            0x7x = Filter Message x = Filter Index 0 - 7, 0x7F = Alle Filter abfragen            |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+            
   2  |             |             |             |             |             |               CAN Channel               |
      |      0      |      0      |      0      |      0      |      0      |                    x                    |     
      +=============+=============+=============+=============+=============+=============+=============+=============+
  
  
CAN TX-Puffer setzen - Standart Frame / Standart CAN-FD Frame
=============================================================
  
 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                                 Command / Indx                                                  |
      |      1      |                       0x6x = Puffer Message x = Puffer Index 0 - 16                             |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |                                                                                                               |
      +-----------                                 Intervall Timer (16Bit)                                 -----------+
   3  |                                                                                                               |      
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+            
   4  |             |     EFF     |     RTR     |             |    CAN FD   |               CAN Channel               |
      |      0      |      0      |      x      |      0      |      x      |                    x                    |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   5  |     BRS     |                ID (Bit 10 - 8)          |                          DLC                          |
      |      x      |                                         |                                                       |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   6  |                                                ID (Bit 7 - 0)                                                 |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   7  |                                               CAN Daten Bytes                                                 |
      +-----------                                                                                         -----------+
   .. |                                                    . . . .                                                    |
      +-----------                                                                                         -----------+
   n  |                                                    . . . .                                                    |
      +=============+=============+=============+=============+=============+=============+=============+=============+

      
CAN TX-Puffer setzen - CAN Extended Frame / CAN-FD Extended Frame
=================================================================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                                 Command / Indx                                                  |
      |      1      |                       0x6x = Puffer Message x = Puffer Index 0 - 16                             |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |                                                                                                               |
      +-----------                                 Intervall Timer (16Bit)                                 -----------+
   3  |                                                                                                               |      
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+            
   4  |             |     EFF     |     RTR     |             |    CAN FD   |               CAN Channel               |
      |      0      |      1      |      x      |      0      |      x      |                    x                    |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   5  |     BRS     |             |             |             |                          DLC                          |
      |      x      |      0      |      0      |      0      |                                                       |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   6  |      0      |      0      |      0      |                           ID (Bit 28 - 24)                          |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   7  |                                               ID (Bit 23 - 16)                                                |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   8  |                                               ID (Bit 15 - 8)                                                 |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   9  |                                                ID (Bit 7 - 0)                                                 |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   10 |                                               CAN Daten Bytes                                                 |
      +-----------                                                                                         -----------+
   .. |                                                    . . . .                                                    |
      +-----------                                                                                         -----------+
   n  |                                                    . . . .                                                    |
      +=============+=============+=============+=============+=============+=============+=============+=============+  

  
  
CAN Standart Frame / Standart CAN-FD Frame
==========================================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |     EFF     |     RTR     |             |    CAN FD   |               CAN Channel               |
      |      0      |      0      |      x      |      0      |      x      |                    x                    |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |     BRS     |             ID (Bit 10 - 8)             |                          DLC                          |
      |      x      |                                         |                                                       |    
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   3  |                                                ID (Bit 7 - 0)                                                 |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   4  |                                               CAN Daten Bytes                                                 |
      +-----------                                                                                         -----------+
   .. |                                                    . . . .                                                    |
      +-----------                                                                                         -----------+
   n  |                                                    . . . .                                                    |
      +=============+=============+=============+=============+=============+=============+=============+=============+


      
CAN Extended Frame / Extended CAN-FD Frame
==========================================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |     EFF     |     RTR     |             |    CAN FD   |               CAN Channel               |
      |      0      |      1      |      x      |      0      |      x      |                    x                    |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |     BRS     |      0      |      0      |      0      |                          DLC                          |
      |      x      |             |             |             |                                                       |       
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   3  |      0      |      0      |      0      |                           ID (Bit 28 - 24)                          |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   4  |                                               ID (Bit 23 - 16)                                                |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   5  |                                               ID (Bit 15 - 8)                                                 |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   6  |                                                ID (Bit 7 - 0)                                                 |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   7  |                                               CAN Daten Bytes                                                 |
      +-----------                                                                                         -----------+
   .. |                                                    . . . .                                                    |
      +-----------                                                                                         -----------+
   n  |                                                    . . . .                                                    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
  


#######################################################################################################################
#                                                          A C K                                                      #
#######################################################################################################################  
    
CAN Standart Frame
==================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |     EFF     |     RTR     |      Tx     |    CAN FD   |               CAN Channel               |
      |      0      |      0      |      x      |      x      |      0      |                    x                    |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |                                                   Time Stamp                                                  |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   3  |      0      |                ID (Bit 10 - 8)          |                          DLC                          |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   4  |                                                ID (Bit 7 - 0)                                                 |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   5  |                                               CAN Daten Bytes                                                 |
      +-----------                                                                                         -----------+
   .. |                                                    . . . .                                                    |
      +-----------                                                                                         -----------+
   n  |                                                    . . . .                                                    |
      +=============+=============+=============+=============+=============+=============+=============+=============+


Standart CAN-FD Frame
=====================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |     EFF     |     RTR     |      Tx     |    CAN FD   |               CAN Channel               |
      |      0      |      0      |      x      |      x      |      1      |                    x                    |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |                                                   Time Stamp                                                  |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+          
   3  |      0      |                ID (Bit 10 - 8)          |                          DLC                          |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   4  |     BRS     |             |             |             |             |             |             |             |
      |      x      |      0      |      0      |      0      |      0      |      0      |      0      |      0      |      
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   5  |                                                ID (Bit 7 - 0)                                                 |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   6  |                                               CAN Daten Bytes                                                 |
      +-----------                                                                                         -----------+
   .. |                                                    . . . .                                                    |
      +-----------                                                                                         -----------+
   n  |                                                    . . . .                                                    |
      +=============+=============+=============+=============+=============+=============+=============+=============+

      
CAN Extended Frame / Standart CAN-FD Frame
==================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |     EFF     |     RTR     |      Tx     |    CAN FD   |               CAN Channel               |
      |      0      |      1      |      x      |      x      |      x      |                    x                    |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |                                                   Time Stamp                                                  |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   3  |      0      |      0      |      0      |      0      |                          DLC                          |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   4  |     BRS     |             |             |                           ID (Bit 28 - 24)                          |
      |      x      |      0      |      0      |                                                                     |   
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   5  |                                               ID (Bit 23 - 16)                                                |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   6  |                                               ID (Bit 15 - 8)                                                 |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   7  |                                                ID (Bit 7 - 0)                                                 |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   8  |                                               CAN Daten Bytes                                                 |
      +-----------                                                                                         -----------+
   .. |                                                    . . . .                                                    |
      +-----------                                                                                         -----------+
   n  |                                                    . . . .                                                    |
      +=============+=============+=============+=============+=============+=============+=============+=============+



CAN Error Frame
===============

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |     EFF     |     RTR     |      Tx     |    CAN FD   |               CAN Channel               |
      |      0      |      0      |      0      |      1      |      0      |                    x                    |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |                                                   Time Stamp                                                  |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   3  |      1      |      0      |  Bus-Fault  |         BUS Status        |           LEC Last Error Code           |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   4  |                                             Receive Error Counter                                             |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   5  |                                            Transmit Error Counter                                             |
      +=============+=============+=============+=============+=============+=============+=============+=============+
      
LEC Last Error Code  
  0 = Normal    
  1 = Stuff Error
  2 = Form Error
  3 = Ack Error
  4 = Bit1 Error        
  5 = Bit0 Error           
  6 = CRC Error      

CAN OV Frame
============

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |     EFF     |     RTR     |      Tx     |    CAN FD   |               CAN Channel               |
      |      0      |      0      |      0      |      1      |      0      |                    x                    |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |                                                   Time Stamp                                                  |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   3  |      1      |      1      |                                  0                                  |      x      |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   4  |                                                                                                               |
      +-----------                                 Messages Lost Counter                                    ----------+
   5  |                                                                                                               |
      +=============+=============+=============+=============+=============+=============+=============+=============+

      
Time Stamp
==========

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                                       Indx                                                      |
      |      1      |                                 0x01 = Time-Stamp                                               |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+   
   2  |                                                                                                               |
      +-----------                                                                                         -----------+
   3  |                                                                                                               |
      +-----------                                 32 Bit Time-Stamp                                       -----------+
   5  |                                                                                                               |
      +-----------                                                                                         -----------+
   5  |                                                                                                               |
      +=============+=============+=============+=============+=============+=============+=============+=============+   
        

        
CAN Status
==========

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                                       Indx                                                      |
      |      1      |                                 0x02 = CAN Status                                               |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |                                                  Device Status                                                |
      |   Power Up  |             |             |             |             |             |             |             | 
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
      |                                                     CAN 0                                                     |      
   3  |  CAN 0 TxD  |     CAN 0 TxD Status      |  CAN 0 RxD  |  CAN 0 RxD  | Bus-Failure |        CAN 0 Status       |
      |    Error    |                           |      OV     |    Pend     |             |                           |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
      |                                                     CAN 1                                                     |
  (4) |  CAN 1 TxD  |     CAN 1 TxD Status      |  CAN 1 RxD  |  CAN 1 RxD  | Bus-Failure |        CAN 1 Status       |
      |    Error    |                           |      OV     |    Pend     |             |                           |                                                                                                                    
      +=============+=============+=============+=============+=============+=============+=============+=============+
 
CAN x TxD Status:
=================
 
CAN x Status:
=============  
  TINY_CAN_OK         (0) => Ok           
  TINY_CAN_WARNING    (1) => Error warning
  TINY_CAN_PASSIV     (2) => Error passiv   
  TINY_CAN_BUS_OFF    (3) => Bus Off        
      
Tx-Box Status
=============

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                                       Indx                                                      |
      |      1      |                                 0x03 = TxCAN Status                                             |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
      |                                                     CAN 0                                                     |
   2  |  Tx-Box 7   |  Tx-Box 6   |  Tx-Box 5   |  Tx-Box 4   |  Tx-Box 3   |  Tx-Box 2   |  Tx-Box 1   |  Tx-Box 0   |
      |   Error     |   Error     |   Error     |   Error     |   Error     |   Error     |   Error     |   Error     |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
      |                                                     CAN 1                                                     |
   3  |  Tx-Box 7   |  Tx-Box 6   |  Tx-Box 5   |  Tx-Box 4   |  Tx-Box 3   |  Tx-Box 2   |  Tx-Box 1   |  Tx-Box 0   |
      |   Error     |   Error     |   Error     |   Error     |   Error     |   Error     |   Error     |   Error     |   
      +=============+=============+=============+=============+=============+=============+=============+=============+



Keys
====

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                                       Indx                                                      |
      |      1      |                                   0x06 = Keys                                                   |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+   
   2  |                                                                                                               |
      +-----------                                                                                         -----------+
   3  |                                                                                                               |
      +-----------                                 32 Bit Key Scan Code                                    -----------+
   5  |                                                                                                               |
      +-----------                                                                                         -----------+
   5  |                                                                                                               |
      +=============+=============+=============+=============+=============+=============+=============+=============+   



Read Analog Inputs
==================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                                       Indx                                                      |
      |      1      |                                 0x07 = Read Analog Inputs                                       |      
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |    AIN 7    |    AIN 6    |    AIN 5    |    AIN 4    |    AIN 3    |    AIN 2    |    AIN 1    |    AIN 0    |      
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   3  |                                                                                                               |
      +-----------                                     Analog Inputs x                                     -----------+
   4  |                                                                                                               |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   .. |                                                                                                               |
      +-----------                                     Analog Inputs x                                     -----------+
   .. |                                                                                                               |               
      +=============+=============+=============+=============+=============+=============+=============+=============+

      
Filter Message - CAN Standart Frame
===================================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                                       Indx                                                      |
      |      1      |                       0x7x = Filter Message x = Filter Index 0 - 16                             |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+      
   2  |             |     EFF     |     RTR     |      Tx     |    CAN FD   |               CAN Channel               |
      |      0      |      0      |      x      |      0      |      0      |                    x                    |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   3  |      0      |                ID (Bit 10 - 8)          |                          DLC                          |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   4  |                                                ID (Bit 7 - 0)                                                 |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   5  |                                               CAN Daten Bytes                                                 |
      +-----------                                                                                         -----------+
   .. |                                                    . . . .                                                    |
      +-----------                                                                                         -----------+
   n  |                                                    . . . .                                                    |
      +=============+=============+=============+=============+=============+=============+=============+=============+


      
Filter Message - CAN Extended Frame
===================================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                                       Indx                                                      |
      |      1      |                       0x7x = Filter Message x = Filter Index 0 - 16                             |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+      
   2  |             |     EFF     |     RTR     |      Tx     |    CAN FD   |               CAN Channel               |
      |      0      |      1      |      x      |      0      |      0      |                    x                    |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   3  |      0      |      0      |      0      |      0      |                          DLC                          |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   4  |      0      |      0      |      0      |                           ID (Bit 28 - 24)                          |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   5  |                                               ID (Bit 23 - 16)                                                |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   6  |                                               ID (Bit 15 - 8)                                                 |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   7  |                                                ID (Bit 7 - 0)                                                 |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   8  |                                               CAN Daten Bytes                                                 |
      +-----------                                                                                         -----------+
   .. |                                                    . . . .                                                    |
      +-----------                                                                                         -----------+
   n  |                                                    . . . .                                                    |
      +=============+=============+=============+=============+=============+=============+=============+=============+


Read Digital Inputs
=================== 

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |           Read Digital Inputs           |   Dig.-In   |   Dig.-In   |  Dig.-In    |  Dig.-In    |
      |      1      |      0      |      1      |      0      |   48 - 63   |   32 - 47   |  16 - 31    |   0 - 15    |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |                                                                                                               |
      +-----------                                    Digital Inputs x                                     -----------+
   3  |                                                                                                               |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   .. |                                                                                                               |
      +-----------                                    Digital Inputs x                                     -----------+
   .. |                                                                                                               |               
      +=============+=============+=============+=============+=============+=============+=============+=============+


Read Incremental Inputs
=======================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |         Read Incremental Inputs         |   Encoder   |   Encoder   |   Encoder   |   Encoder   |
      |      1      |      0      |      1      |      1      |      3      |      2      |      1      |      0      |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |                                                                                                               |
      +-----------                                   Incremental Input x                                   -----------+
   3  |                                                                                                               |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   .. |                                                                                                               |
      +-----------                                   Incremental Input x                                   -----------+
   .. |                                                                                                               |               
      +=============+=============+=============+=============+=============+=============+=============+=============+


Data Status (ECU Flash)
=======================

 Byte |    Bit 7    |    Bit 6    |    Bit 5    |    Bit 4    |    Bit 3    |    Bit 2    |    Bit 1    |    Bit 0    |
      +=============+=============+=============+=============+=============+=============+=============+=============+
   1  |No CAN Frame |                   Data                  |             |             |             |             |
      |      1      |      1      |      0      |      1      |      0      |      0      |      0      |      0      |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   2  |    Error    |                 Error Code              |             |             |   Rx-ACK    | Buffer Free |
      |      x      |      x      |      x      |      x      |      0      |      0      |      x      |      x      |
      +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
   3  |                                                                                                               |
      +-----------                                          Free                                           -----------+      
   4  |                                                                                                               |      
      +=============+=============+=============+=============+=============+=============+=============+=============+              
                     
*/                                                                                                          

#define DATA_STREAM_SUPPORT_FD         0x40
#define DATA_STREM_FILTER_MSG          0x80


static const char CanStatusTranslate[4] =
  {CAN_STATUS_OK,          // TINY_CAN_OK         (0) => Ok
   CAN_STATUS_WARNING,     // TINY_CAN_WARNING    (1) => Error warning
   CAN_STATUS_PASSIV,      // TINY_CAN_PASSIV     (2) => Error passiv
   CAN_STATUS_BUS_OFF};    // TINY_CAN_BUS_OFF    (3) => Bus Off
 

static int32_t ExtractDigIn(TCanDevice *dev, uint8_t **src, int32_t *size)
{
TMhsObjContext *context;
uint8_t *data;
int32_t count;
uint8_t idx, get_ports;
uint16_t din;
char str[11];

if ((!size) || (!src))
  return(ERR_FATAL_INTERNEL_ERROR);
count = *size;
data = *src;
if (count < 3)
  return(ERR_COMM_STREAM_SIZE);
context = dev->Context;  
get_ports = (*data++) & 0x0F;        // Header überspringen
for (idx = 0; idx < 4; idx++)
  {
  if (get_ports & 0x01)
    {  
    din = *((uint16_t *)data);
    safe_sprintf(str, 10, "IoPort%uIn", idx);
    (void)mhs_value_set_as_uword(str, din, ACCESS_PUBLIC, 0, context);

    data += 2;
    count -= 2;
    }
  get_ports >>= 1;  
  }
*src = data;   
*size = count - 1;
return(0);
}


static int32_t ExtractAnalogIn(TCanDevice *dev, uint8_t **src, int32_t *size)
{
TMhsObjContext *context;
uint8_t *data;
int32_t count;
uint8_t idx, get_ports;
uint16_t din;
char str[16];

if ((!size) || (!src))
  return(ERR_FATAL_INTERNEL_ERROR);
count = *size;
data = *src;
if (count < 3)
  return(ERR_COMM_STREAM_SIZE);
context = dev->Context;
data++;                       // Header überspringen
get_ports = *data++;        
for (idx = 0; idx < 8; idx++)
  {
  if (get_ports & 0x01)
    {  
    din = *((uint16_t *)data);
    safe_sprintf(str, 15, "IoPort%uAnalog", idx);
    (void)mhs_value_set_as_uword(str, din, ACCESS_PUBLIC, 0, context);

    data += 2;
    count -= 2;
    }
  get_ports >>= 1;  
  }
*src = data;   
*size = count - 2;
return(0);
}


static int32_t ExtractKeys(TCanDevice *dev, uint8_t **src, int32_t *size)
{
uint8_t *data;
int32_t count;
uint32_t keys;

if ((!size) || (!src))
  return(ERR_FATAL_INTERNEL_ERROR);
count = *size;
data = *src;
data++;                       // Header überspringen
if (count < 5)
  return(ERR_COMM_STREAM_SIZE);
keys = *((uint32_t *)data);  
(void)mhs_value_set_as_ulong("Keycode", keys, ACCESS_PUBLIC, 0, dev->Context);
*src = data + 4;   
*size = count - 5;
return(0);
}


static int32_t ExtractEncoderIn(TCanDevice *dev, uint8_t **src, int32_t *size)
{
TMhsObjContext *context;
uint8_t *data;
int32_t count;
uint8_t idx, get_ports;
int16_t delta;
int32_t enc;
char str[15];

if ((!size) || (!src))
  return(ERR_FATAL_INTERNEL_ERROR);
count = *size;
data = *src;
if (count < 3)
  return(ERR_COMM_STREAM_SIZE);
context = dev->Context;  
get_ports = (*data++) & 0x0F;        // Header überspringen
for (idx = 0; idx < 4; idx++)
  {
  if (get_ports & 0x01)
    {  
    delta = *((int16_t *)data);
    safe_sprintf(str, 14, "IoPort%uEnc", idx);
    enc = mhs_value_get_as_long(str, ACCESS_PUBLIC, context);
    enc += (int32_t)delta;
    (void)mhs_value_set_as_long(str, enc, ACCESS_PUBLIC, 0, context);

    data += 2;
    count -= 2;
    }
  get_ports >>= 1;  
  }
*src = data;   
*size = count - 1;
return(0);
}


static void SetCanDataStatus(TCanDevice *dev, int32_t status)
{
if (dev->CanDataStatus != status)
  {
  dev->CanDataStatus = status;
  (void)mhs_value_set_as_long("CanDataStatus", status, ACCESS_PUBLIC, 0, dev->Context);
  }
}


static int32_t ExtractDataStatus(TCanDevice *dev, uint8_t **src, int32_t *size)
{
uint8_t *data;
int32_t count;
uint8_t status;

if ((!size) || (!src))
  return(ERR_FATAL_INTERNEL_ERROR);  
count = *size;
data = *src;
if (count < 4)
  return(ERR_COMM_STREAM_SIZE);
data++;        // Header überspringen
status = *data++; 
dev->CanDataFreeSize = *((int16_t *)data);
data += 2;
if (dev->CanDataExec == CAN_DATA_EXEC_END_WAIT)
  {
  if (status & ECU_DATA_ST_RX_ACK)
    {
    SetCanDataStatus(dev, CAN_DATA_ST_FINISH);
    dev->CanDataExec = CAN_DATA_EXEC_IDLE;
    }
  else if (status & ECU_DATA_ST_ERROR)  
    {
    switch ((status & 0x70))
      {
      case ECU_DATA_ST_RX_TIMEOUT :
              {
              SetCanDataStatus(dev, CAN_DATA_ST_ERR_ACK_TIMEOUT);
              break;
              }      
      case ECU_DATA_ST_RX_NACK :
              {
              SetCanDataStatus(dev, CAN_DATA_ST_ERR_NACK);
              break;
              }      
      case ECU_DATA_ST_OVERFLOW :
              {
              SetCanDataStatus(dev, CAN_DATA_ST_ERR_OVERFLOW);
              break;
              }      
      case ECU_DATA_ST_ISOTP_ERROR :
              {
              SetCanDataStatus(dev, CAN_DATA_ST_ERR_ISOTP);
              break;
              }
      }       
    dev->CanDataExec = CAN_DATA_EXEC_IDLE;
    }  
  }
*src = data;   
*size = count - 4;
return(0);
}


static int32_t ExtractTimeStamp(TCanDevice *dev, uint8_t **src, int32_t *size)
{
uint8_t *data;
int32_t count;

if ((!size) || (!src))
  return(ERR_FATAL_INTERNEL_ERROR);
count = *size;
data = *src;
if (count < 5)
  return(ERR_COMM_STREAM_SIZE);
data++;        // Header überspringen  
dev->TimeStampMarker = *((uint32_t *)data);
data += 4;
*src = data;   
*size = count - 5;
return(0);
}


static int32_t ExtractTarStatus(struct TTar2Status *tar_status, uint8_t **src, int32_t *size, uint8_t channels)
{
uint8_t *data;
int32_t count;

if ((!size) || (!src))
  return(ERR_FATAL_INTERNEL_ERROR);  
count = *size;
data = *src;
if (count < (2 + channels))
  return(ERR_COMM_STREAM_SIZE);
data++;        // Header überspringen
tar_status->DevStatus.Byte = *data++; 
tar_status->CanStatus[0].Byte = *data++;
if (channels > 1)
  tar_status->CanStatus[1].Byte = *data++;  
*src = data;   
*size = count - (2 + channels);
return(0);
}


static int32_t ExtractCanFdMsg(TCanDevice *dev, struct TCanFdMsg *msg, uint8_t **src, int32_t *size, uint8_t mode)
{
uint8_t *data;
int32_t res, count, block_size;
uint8_t header, len, id_dlc, time_stamp_low, fd_flags;
uint32_t id, t, time_stamp;

res = 1;
if ((!size) || (!src))
  return(ERR_FATAL_INTERNEL_ERROR);
count = *size;
data = *src;
time_stamp = dev->TimeStampMarker;
msg->MsgFlags = 0;
if (count == 0)    
  return(0);
// 1. Byte -> Header  
header = *data++;  
// 2. Byte -> TimeStamp
if (mode & DATA_STREM_FILTER_MSG)
  {
  if (count < 3)    
    return(ERR_COMM_STREAM_SIZE);
  block_size = 3;
  time_stamp_low = 0;
  }
else  
  {
  if (count < 4)    
    return(ERR_COMM_STREAM_SIZE);
  block_size = 4;  
  time_stamp_low = *data++; 
  }    
// 3. Byte -> (ID)/DLC
id_dlc = *data++;

if (((header & 0xF8) == 0x10) && (id_dlc & 0x80))   // Error / OV Message
  {
  block_size += 1;
  if (block_size > count)
    return(ERR_COMM_STREAM_SIZE); 
  msg->Id = 0x80000000;
  if (id_dlc & 0x40)  // OV - Frame
    {
    if (dev->OvMode & 0x8000)
      {
      res = 0;
      data += 2;
      }
    else
      {  
      msg->MsgLen = 3;
      msg->MsgOV = 1;
      if (id_dlc & 0x01)
        msg->MsgData[0] = 0x02;
      else
        msg->MsgData[0] = 0x01;
      msg->MsgData[1] = *data++;
      msg->MsgData[2] = *data++;
      }  
    }
  else
    {                 // Error Frame
    msg->MsgLen = 4;
    msg->MsgErr = 1;
    msg->MsgData[0] = id_dlc & 0x07;
    if (id_dlc & 0x20)         // Bus Off
      msg->MsgData[1] = 3;  
    else if (id_dlc & 0x08)    // Error Passiv
      msg->MsgData[1] = 2;
    else if (id_dlc & 0x10)    // Error Warning
      msg->MsgData[1] = 1;  
    else
      msg->MsgData[1] = 0;
    if (msg->Id & 0x40)
      msg->MsgData[1] |= 0x10;  
    msg->MsgData[2] = *data++; // Receive Error Counter
    msg->MsgData[3] = *data++; // Transmit Error Counter
    }           
  }
else
  {
  if (mode & DATA_STREAM_SUPPORT_FD)
    {
    if (header & DATA_STREM_FD_FLAG)
      msg->MsgFD = 1;
    len = DlcLenTab[(id_dlc & 0x0F)];
    }
  else
    len = id_dlc & 0x0F;  
  msg->MsgLen = len;      // Dlc extrahieren    
  msg->MsgSource = header & DATA_STREM_CAN_CHANNEL;
  if (header & DATA_STREM_TX_FLAG)
    msg->MsgTxD = 1; 
  if (header & DATA_STREM_RTR_FLAG)
    {
    len = 0;
    msg->MsgRTR = 1;
    }  
  block_size += len;
  if (header & DATA_STREM_EFF_FLAG)
    {  // ****** EFF Frame
    msg->MsgEFF = 1;
    block_size += 3;
    if (block_size > count)
      return(ERR_COMM_STREAM_SIZE);
    id = *((uint32_t *)data);     
    data += 4;
    if ((mode & DATA_STREAM_SUPPORT_FD) && (header & DATA_STREM_FD_FLAG))
      {
      if (id & 0x80000000) 
        msg->MsgBRS = 1;      
      }    
    msg->Id = id & 0x1FFFFFFF;    
    }
  else 
    {  // ****** STD Frame
    if ((mode & DATA_STREAM_SUPPORT_FD) && (header & DATA_STREM_FD_FLAG))
      block_size++;
    if (block_size > count)
      return(ERR_COMM_STREAM_SIZE);
    if ((mode & DATA_STREAM_SUPPORT_FD) && (header & DATA_STREM_FD_FLAG))
      {
      fd_flags = *data++;  
      if (fd_flags & DATA_STREM_BRS_FLAG) 
        msg->MsgBRS = 1;
      }      
    msg->Id = *data++ | (((uint16_t)id_dlc << 4) & 0x0700); // Id extrahieren  
    }
  // **** Daten lesen
  if (len)
    {
    memcpy(&msg->MsgData, data, len); // Daten in FIFO kopieren
    data += len;
    }
  }    
// **** Time Stamp
if ((mode & DATA_STREM_FILTER_MSG))
  {  // Filter Message
  msg->Time.Sec = 0L;
  msg->Time.USec = 0L;
  }
else
  {  
  t = (time_stamp & 0xFFFFFF00) | time_stamp_low;
  if (t < time_stamp)
    t += 0x00000100;
  time_stamp = t;  
  mode &= 0x0F;  
  if (mode >= TIME_STAMP_HW_UNIX)
    {
    if (mode == TIME_STAMP_HW)
      {    
      msg->Time.Sec = 0;
      msg->Time.USec = t;
      }
    else
      {    
      msg->Time.Sec = t / 10000;
      msg->Time.USec = (t % 10000) * 100;
      }
    }
  else if (mode == TIME_STAMP_SOFT)  
    get_timestamp(&msg->Time);  
  else
    {
    msg->Time.Sec = 0L;
    msg->Time.USec = 0L;
    }
  }  
// size & data anpassen
*src = data;   
*size = count - block_size;
dev->TimeStampMarker = time_stamp;  // Update Timestamp Marker
return(res);    // CAN Message erfolgreich gelesen
}


void SetTar2StatusToDev(TCanDevice *dev, struct TTar2Status *tar_status)
{
// **** CAN 0 Status
dev->DeviceStatus.CanStatus = CanStatusTranslate[tar_status->CanStatus[0].Flag.BusStatus];
if (tar_status->CanStatus[0].Flag.BusFailure)  
  dev->DeviceStatus.CanStatus |= BUS_FAILURE;
// Puffer Status
if (tar_status->CanStatus[0].Flag.RxDOv)
  {
  dev->DeviceStatus.FifoStatus |= FIFO_HW_OVERRUN;
#ifdef ENABLE_LOG_SUPPORT
  if (LogEnable)
    LogPrintf(LOG_ERROR , "FEHLER: [SetDrvStatus] CanRxOv");
#endif
  }  
if (tar_status->CanStatus[0].Flag.TxDStatus == TXD_STATUS_EMPTY)
  dev->HwTxDFifoCount[0] = 0;
else if (tar_status->CanStatus[0].Flag.TxDStatus == TXD_STATUS_PEND)
  {
  if (dev->HwTxDFifoCount[0] > dev->ModulDesc->HwTxFifoLimit)
    dev->HwTxDFifoCount[0] = dev->ModulDesc->HwTxFifoLimit; 
  }
else
  dev->ReadStatusFlag = 1;  
// **** CAN 1 Status
//CanStatusTranslate[tar_status->CanStatus[1].Flag.BusStatus];    
if (tar_status->CanStatus[1].Flag.TxDStatus == TXD_STATUS_EMPTY)
  dev->HwTxDFifoCount[1] = 0;
else if (tar_status->CanStatus[1].Flag.TxDStatus == TXD_STATUS_PEND)
  {
  if (dev->HwTxDFifoCount[1] > dev->ModulDesc->HwTxFifoLimit)
    dev->HwTxDFifoCount[1] = dev->ModulDesc->HwTxFifoLimit;
  }
else
  dev->ReadStatusFlag = 1;  
}


static int32_t CanTxDProcessMessages(uint8_t **dst, uint8_t channel, struct TCanFdMsg *msgs, uint16_t count, uint8_t fd_en)
{
uint8_t *data;
int32_t size;
uint8_t brs_dlc, len, header;

size = 0;
data = *dst;
for (; count; count--)
  {
  len = msgs->MsgLen;
  header = channel & 0x07;
  if (msgs->MsgFD)
    {
    if (!fd_en)   // Kein CAN-FD Device, FD-Frames überspringen
      {
      msgs++;
      continue;
      }  
    brs_dlc = LenToDlc(len);
    header |= DATA_STREM_FD_FLAG;        
    if (msgs->MsgBRS)
      brs_dlc |= DATA_STREM_BRS_FLAG;
    }
  else
    brs_dlc = len;    
  if (msgs->MsgRTR)
    {
    len = 0;
    header |= DATA_STREM_RTR_FLAG;
    }     
  if (msgs->MsgEFF)
    {    
    header |= DATA_STREM_EFF_FLAG;
    size += 6;
    }
  else
    size += 3;   
  *data++ = header;
  
  if (msgs->MsgEFF)  
    {
    *data++ = brs_dlc;         
    *(uint32_t *)data = (uint32_t)msgs->Id;
    data += 4;
    }
  else
    { // STD
    *data++ = (uint8_t)(((msgs->Id >> 4) & 0x70) | brs_dlc);
    *data++ = (uint8_t)msgs->Id;
    }
  if (len)
    {
    memcpy(data, &msgs->MsgData, len);
    data += len;
    size += len;
    }
  msgs++;
  }
*dst = data;  
return(size);
}


static uint32_t CanEcuFlashDataGetToWrite(TCanDevice *dev, uint8_t *data, uint32_t free_size, uint32_t available_size, uint32_t *status)
{
int res;
uint32_t total_write, to_write, n, s;

if ((!dev->IsoTpBlockSize) && (dev->GetDataBlockCb))
  {
  dev->IsoTpBlockWritten = 0;
  if ((res = (dev->GetDataBlockCb)(dev->IsoTpTxBuf, MAX_ISO_TP_MSG_LENGTH, dev->GetDataBlockUserData)) > -1)
    dev->IsoTpBlockSize = res;
  else  
    dev->IsoTpBlockSize = 0;
  }  
to_write = dev->IsoTpBlockSize - dev->IsoTpBlockWritten;
if (dev->CanDataBuf)
  {
  total_write = dev->CanDataBufSize - dev->CanDataBufWritten;
  if (total_write < to_write)
    to_write = total_write; // letzter Block
  }
n = to_write;  
if (to_write > free_size)
  to_write = free_size;
if (to_write > available_size)
  to_write = available_size;
if (to_write)
  {  
  if (dev->CanDataBuf)
    mhs_memcpy(data, &dev->CanDataBuf[dev->CanDataBufWritten], to_write);
  else
    mhs_memcpy(data, &dev->IsoTpTxBuf[dev->IsoTpBlockWritten], to_write);    
  }    
if (n == to_write)
  {  
  dev->IsoTpBlockWritten = 0;
  if (dev->GetDataBlockCb)
    {
    if ((res = (dev->GetDataBlockCb)(dev->IsoTpTxBuf, MAX_ISO_TP_MSG_LENGTH, dev->GetDataBlockUserData)) > -1)
      dev->IsoTpBlockSize = res;
    else  
      dev->IsoTpBlockSize = 0;  
    }  
  s = CAN_ECU_BLOCK_END;
  }    
else
  {
  dev->IsoTpBlockWritten += to_write;
  s = 0;
  }    
if (status) 
  *status = s;   
return(to_write);
}


static int32_t CanEcuFlashDataProcess(uint8_t **dst, uint32_t available_size, TCanDevice *dev)
{
TMhsObjContext *context;
uint8_t *data;
int32_t size, free_size;
uint32_t to_write, status;

context = dev->Context;
size = 1;
data = *dst;
available_size--;
to_write = 0;
status = 0;
if (dev->CanDataExec == CAN_DATA_EXEC_START)
  { // **** Start
  *data = DATA_STREAM_CMD_DATA | ECU_DATA_CMD_CLEAR | ECU_DATA_FLAG_DATA;
  dev->CanDataBufWritten = 0;
  dev->IsoTpBlockWritten = 0;
  if (dev->GetDataBlockCb)
    dev->IsoTpBlockSize = 0;
  to_write = CanEcuFlashDataGetToWrite(dev, data + 1, MAX_ISO_TP_MSG_LENGTH, available_size, NULL);  
  dev->CanDataExec = CAN_DATA_EXEC_RUN; 
  SetCanDataStatus(dev, CAN_DATA_ST_RUN);
  }
else if (dev->CanDataExec == CAN_DATA_EXEC_CANCEL)
  {
  *data = DATA_STREAM_CMD_DATA | ECU_DATA_CMD_CANCEL;
  dev->CanDataExec = CAN_DATA_EXEC_IDLE;
  SetCanDataStatus(dev, CAN_DATA_ST_IDLE);
  }
else if (dev->CanDataExec == CAN_DATA_EXEC_RUN)
  { // **** Run
  if ((free_size = dev->CanDataFreeSize) < 1)
    *data = DATA_STREAM_CMD_DATA;
  else
    {  
    to_write = CanEcuFlashDataGetToWrite(dev, data + 1, (uint32_t)free_size, available_size, &status);
    if (to_write)
      {
      if (status & CAN_ECU_BLOCK_END)  
        *data = DATA_STREAM_CMD_DATA | ECU_DATA_CMD_FINISH | ECU_DATA_FLAG_DATA;
      else    
        *data = DATA_STREAM_CMD_DATA | ECU_DATA_FLAG_DATA;
      }
    else
      dev->CanDataExec = CAN_DATA_EXEC_END_WAIT;          
    }
  }  
if (dev->CanDataExec == CAN_DATA_EXEC_END_WAIT)
  *data = DATA_STREAM_CMD_DATA;
if (to_write)
  { 
  data += to_write;
  size += to_write;
  dev->CanDataBufWritten += to_write;
  (void)mhs_value_set_as_long("CanDataBufWritten", dev->CanDataBufWritten, ACCESS_PUBLIC, 0, context);
  dev->CanDataFreeSize = -1;  // Muss neu abgefragt werden
  }
*dst = data + 1;  
return(size);
}


int32_t MainComm2Proc(TCanDevice *dev, uint32_t mode)
{
#if TX_PUFFER_MAX > 0
TMhsObj *obj;
TMhsObjContext *tx_puffer_context;
TObjCanPuffer *puffer;
uint16_t intervall;
TObjCanFifo *fifo; 
union TCanIndex index;
#endif
int32_t size, err, res, tx_msg_count;
uint32_t idx, h, i, filter_read_intervall;
struct TTar2Status tar_status;
struct TCanFdMsg fd_msg;
uint8_t *data;
uint8_t header, time_stamp_mode, rx_msg, channels, channel, mask, fd_en;

if (dev->CanFd)
  fd_en = DATA_STREAM_SUPPORT_FD;
else
  fd_en = 0;
filter_read_intervall = dev->FilterReadIntervall; 
// **** Timestamp lesen
if ((dev->ModulDesc->SupportHwTimestamp) && (dev->TimeStampMode >= TIME_STAMP_HW_UNIX))
  time_stamp_mode = dev->TimeStampMode;
else if ((dev->TimeStampMode == TIME_STAMP_SOFT) || (dev->TimeStampMode == TIME_STAMP_HW_SW_UNIX))
  time_stamp_mode = TIME_STAMP_SOFT;
else
  time_stamp_mode = 0;
channels = (uint8_t)dev->ModulDesc->CanChannels;  
err = 0;    
/**********************************/
/* Get Kommando Daten aufbereiten */
/**********************************/
size = 0;
data = &dev->TxDParameter.Data[0];
// ****** Festlegen ob Status abgefragt wird
if (mhs_diff_time(dev->TimeNow, dev->StatusTimeStamp) >= STATUS_READ_TIMEOUT)    
  dev->ReadStatusFlag = 1;  
if (dev->ReadStatusFlag)
  {
  dev->StatusTimeStamp = dev->TimeNow;     // Status Timeout resetten
  dev->ReadStatusFlag = 0;
  *data++ = DATA_STREAM_CMD_CAN_STATUS;
  size++;  
  }    
// ****** Festlegen ob Filter Nachrichten abgefragt werden
#if RX_FILTER_MAX > 0
if (mhs_diff_time(dev->TimeNow, dev->FilterTimeStamp) >= filter_read_intervall) 
  {
  dev->FilterTimeStamp = dev->TimeNow;     // Filter Timeout resetten
  for (channel = 0; channel < channels; channel++)
    {
    *data++ = DATA_STREAM_CMD_FILTER_MSG | 0x0F;
    *data++ = channel;     
    size += 2;
    }   
  } 
#endif
if (mode)
  {
  // Alle Dig Inputs lesen
  *data++ = DATA_STREAM_CMD_GET_DIG_IN | 0x0F;
  size++;
  // Alle Analog Inputs lesen
  *data++ = DATA_STREAM_CMD_GET_AD_IN;
  size++;  
  }
// ****** Intervall Puffer updaten
#if TX_PUFFER_MAX > 0
tx_puffer_context = dev->TxPufferContext;
if (mode)
  {  
  // Alle TxD Puffer setzen     
  index.Long = dev->Index | INDEX_TXT_FLAG;
  for (channel = 0; channel < channels; channel++)
    {
    index.Item.Channel = channel;
    for (i = 1; i <= dev->ModulDesc->HwTxPufferCount; i++)
      {   
      intervall = 0; 
      index.Item.SubIndex = i; 
      if ((puffer = (TObjCanPuffer *)mhs_object_get_by_index(index.Long, tx_puffer_context)))
        {
        if (mhs_can_puffer_get_fd_copy(puffer, &fd_msg) > -1)                  
          intervall = (uint16_t)(mhs_can_puffer_get_intervall(puffer) / 1000);          
        }
      if (!intervall)
        memset(&fd_msg, 0, sizeof(struct TCanFdMsg));
      *data++ = DATA_STREAM_CMD_TX_PUFFER_MSG | (uint8_t)(i - 1);  
      *(uint16_t *)data = intervall;
      data += 2;  
      size += (CanTxDProcessMessages(&data, channel, &fd_msg, 1, fd_en) + 3);
#ifdef ENABLE_LOG_SUPPORT
      if (LogEnable)
        {
        index.Long |= dev->Index;
        LogCanFdMessage(LOG_TX_MSG, &fd_msg, LOG_FMT_FD_TYPE, "TXD Puffer Index: %#08X, Intervall: %5u Msg:", index.Long, intervall);
        }
#endif
      }
    }      
  }
else
  {
  for (i = 32; i; i--)
    {
    if (!(obj = mhs_object_get_cmd_marked(tx_puffer_context)))
      break;  
    index.Long = obj->Index;
    if (index.Item.SubIndex > dev->ModulDesc->HwTxPufferCount)
      continue;
    channel = index.Item.Channel;  
    i = index.Item.SubIndex;
    puffer = (TObjCanPuffer *)obj;

    if (mhs_can_puffer_get_fd_copy(puffer, &fd_msg) < 0)
      {
      memset(&fd_msg, 0, sizeof(struct TCanFdMsg));
      intervall = 0;      
      }
    else  
      intervall = (uint16_t)(mhs_can_puffer_get_intervall(puffer) / 1000);
    *data++ = DATA_STREAM_CMD_TX_PUFFER_MSG | (uint8_t)(i - 1);  
    *(uint16_t *)data = intervall;
    data += 2;  
    size += (CanTxDProcessMessages(&data, channel, &fd_msg, 1, fd_en) + 3);  
#ifdef ENABLE_LOG_SUPPORT
    if (LogEnable)
      LogCanFdMessage(LOG_TX_MSG, &fd_msg, LOG_FMT_FD_TYPE, "TXD Puffer Index: %#08X, Intervall: %5u Msg:", index.Long, intervall);      
#endif    
    }
  } 
#endif  
// ****** Digital-I/O setzen
if ((i = dev->ModulDesc->DigIoCount))
  {
  if (dev->DigOutSet)
    {
    *data++ = DATA_STREAM_CMD_SET_DIG_OUT | dev->DigOutSet;    
    size++;    
    mask = 0x01;    
    idx = i / 16;
    if ((i % 16))
      idx++;
    for (i = 0; i < idx; i++)
      {
      if (dev->DigOutSet & mask)
        {
        *(uint16_t *)data = dev->DigOut[i];
        data += 2;        
        size += 2;
        }        
      mask <<= 1;  
      }
    dev->DigOutSet = 0x00;  
    }
  if (dev->AnalogOutSet)
    {  
    *data++ = DATA_STREAM_CMD_SET_AD_OUT | dev->AnalogOutSet;
    size++;
    mask = 0x01;
    for (i = 0; i < 4; i++)
      {
      if (dev->AnalogOutSet & mask)
        {
        *(uint16_t *)data = dev->AnalogOut[i];
        data += 2;        
        size += 2;        
        }
      mask <<= 1;  
      }
    dev->AnalogOutSet = 0x00;   
    }            
  }
#ifdef ENABLE_RS485_SUPPORT // <*> neu 
if ((h = dev->ModulDesc->RxMtu - size) >= RS485_MIN_CMD_SIZE)  
  size += ProcessRS485Cmd(&data, h, dev);
#endif    
// ****** Versand von CAN Nachrichten
tx_msg_count = 0;
for (channel = 0; channel < channels; channel++)
  {
  if (fd_en)    
    h = (dev->ModulDesc->RxMtu - size) / TX_CAN_FD_PKT_MAX_SIZE;
  else  
    h = (dev->ModulDesc->RxMtu - size) / TX_CAN_PKT_MAX_SIZE;
  if (!h)
    break;
  idx = dev->Index | (channel << 16) | INDEX_TXT_FLAG;
  if (dev->HwTxDFifoCount[channel] < dev->ModulDesc->HwTxFifoSize)
    {
    i = dev->ModulDesc->HwTxFifoSize - dev->HwTxDFifoCount[channel];               
    if (i > h)
      i = h;                      
    if (!(fifo = mhs_can_fifo_get_obj_by_index(idx)))
      continue;
    if ((res = mhs_can_fifo_get_fd(fifo, dev->TxCanBuffer, i)) > 0) // <*> ändern! ??
      {
      dev->ReadStatusFlag = 1;
      dev->HwTxDFifoCount[channel] += res;
      size += CanTxDProcessMessages(&data, (uint8_t)channel, dev->TxCanBuffer, (uint16_t)res, fd_en);
      tx_msg_count += res;   
#ifdef ENABLE_LOG_SUPPORT
      if (LogEnable) 
        LogCanFdMessages(LOG_TX_MSG, dev->TxCanBuffer, res, LOG_FMT_FD_TYPE,
             "TXD Messages Dev:%2u Ch:%2u", dev->Index, channel);
#endif
      res = mhs_can_fifo_count(fifo);
      if (res <= (int32_t)dev->TxCanFifoEventLimit)
        (void)mhs_object_set_event((TMhsObj *)fifo);  
      }
    }
  }
if ((!tx_msg_count) && (dev->EcuFlashMode))
  {  
  // <*> neu ECU Flash  
  if (dev->CanDataExec)  
    {
    if ((h = dev->ModulDesc->RxMtu - size))
      size += CanEcuFlashDataProcess(&data, h, dev);
    }
  }        
dev->TxDParameter.Count = size;
/**********************************/
/* Kommando senden                */
/**********************************/
dev->Kommando = CMD2_COM;
err = SMDrvCommando(dev, 0);
rx_msg = 0;
if (!err)
  {
  /**********************************/
  /* Empfangene Daten verarbeiten   */
  /**********************************/
  size = dev->RxDParameter.Count;
  data = &dev->RxDParameter.Data[0];
  while (size)
    {
    header = *data;
    if (header & DATA_STREM_NO_CAN_FLAG)
      {  // **** keine CAN Nachricht
      if (header & 0x70)
        {
        switch (header & 0xF0)
          { 
          case DATA_STREAM_CMD_FILTER_MSG :
                       {
                       size--;
                       data++;
                       if ((err = ExtractCanFdMsg(dev, &fd_msg, &data, &size, (uint8_t)(fd_en | DATA_STREM_FILTER_MSG))) < 0) 
                         break;                        
                       // **** CAN Message speichern                                               
                       i = fd_msg.MsgSource;
                       idx = (i << 16) | ((header & 0x0F) + 1);
                       (void)mhs_can_puffer_put_fd_by_index(idx, &fd_msg, dev->RxFilterContext);                         
                       break;          
                       }
          case DATA_STREAM_CMD_GET_DIG_IN :
                       {
                       err = ExtractDigIn(dev, &data, &size);
                       break;
                       }                       
          case DATA_STREAM_CMD_GET_ENC :             
                       {
                       err = ExtractEncoderIn(dev, &data, &size);
                       break;
                       }
          case DATA_STREAM_CMD_DATA :
                       {
                       err = ExtractDataStatus(dev, &data, &size); 
                       break;
                       }                       
          default    : err = ERR_COMM_STREAM_FORMAT;                                    
          }
        if (err < 0)
          break;               
        }
      else
        {  
        switch (header)
          {
          case DATA_STREAM_CMD_TIME_STAMP :
              {
              err = ExtractTimeStamp(dev, &data, &size);
              break;
              }
          case DATA_STREAM_CMD_CAN_STATUS :
              {                          
              dev->StatusTimeStamp = dev->TimeNow;     // Status Timeout resetten
              err = ExtractTarStatus(&tar_status, &data, &size, channels);            
              if (dev->ReadStatusFlag) // Status verwerfen, neu abfragen
                break;
              SetTar2StatusToDev(dev, &tar_status);
              break;
              }
          case DATA_STREAM_CMD_TX_CAN_STATUS :
              {
              // <*> T.D.              
              break;
              }
          case DATA_STREAM_CMD_GET_KEYS :
              {
              err = ExtractKeys(dev, &data, &size);
              break;
              }    
          case DATA_STREAM_CMD_GET_AD_IN :
              {
              err = ExtractAnalogIn(dev, &data, &size);
              break;
              }
#ifdef ENABLE_RS485_SUPPORT // <*> neu              
           case DATA_STREAM_CMD_RS485 :
              {
              err = ExtractRS485Data(dev, &data, &size);
              break;
              }    
#endif              
          default : err = ERR_COMM_STREAM_FORMAT;        
          }                
        }
      if (err < 0)
        break;  
      }
    else
      {  // **** CAN Nachrichten verarbeiten
      if ((err = ExtractCanFdMsg(dev, &fd_msg, &data, &size, (uint8_t)(fd_en | time_stamp_mode))) < 0)
        break; 
      if (err > 0)
        {
        rx_msg = 1;  
        // **** CAN Message speichern
        process_rx_msg(dev->Index, &fd_msg);  
#ifdef ENABLE_LOG_SUPPORT
        // **** Log Datei schreiben
        if (LogEnable) 
          LogCanFdMessage(LOG_RX_MSG | LOG_ERR_MSG | LOG_OV_MSG, &fd_msg, LOG_FMT_FD_TYPE_SOURCE, "[RxD]");
#endif
        }                                
      }    
    }
  if (!rx_msg)  
    {
    if (dev->CommIdleCounter)
      dev->CommIdleCounter--;
    }
  }
LOG_FUNCTION_ERROR("MainCommProc", err);
return(err);
}

